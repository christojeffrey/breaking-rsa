# known plaintext?
import gmpy2

# https://crypto.stackexchange.com/questions/93687/in-rsa-signing-find-n-from-e-and-many-pairs-of-m-and-c

m1 = 2
c1 = 43783989103723272913499891323241702745671474064559711101183772360609223991605563784927872686223682745127121831064520899606621050949350106828940656941781861936632616031658819809113895163662476566510477513672377899363914226718121633071709518788269378117638717715107432290185282957423766766220834446728529241


m2 = 3
c2 = 76864444194080838134435006843149365884256760276752809503840041723143318825104112290506139839894930724819652361750062976914581890401955836199365777795319219326198569468619190252228159769011133053551680186606056615237927371606037184652478498092983550203128715707042680102497936073138168894963728885360862395557

eLow = 2**15
eHigh = 2**16

# brute force find n

for e in range(eLow, eHigh):
    firstPart = pow(m1, e) - c1
    secondPart = pow(m2, e) - c2
    multipleofn = gmpy2.gcd(firstPart, secondPart)
    if(multipleofn != 1):
        print(multipleofn)
        print(e)
        # break

