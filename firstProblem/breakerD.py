# small e. 
# we can brute force. probably no 'wrap around'
# m^e = c mod n
# m^e = c + k*n, probably k will be low.
import gmpy2
from Crypto.Util.number import *
n = 19253894033986622094429586057247117719947186948559976123778857060942139475050836745464611385975486133751442000513269155692366970900036150210918440261959115937082520056087546281065330432070527616985990559137540606161140190993178960226582395978681930491448623915800784080237937046149042628915807259141045135454067222381385398077192636484173960384705876594447543506710257543695596817789216251414286954069614816019101928297363078804233126193399440690900639321983848673212704973976467467896010754655394489600422274131974739652286037071278824350336272834041118531348991124114431957157930617641727829909579831982402841072929

e = 3

c = 79512189580798597445445851463057564001134552415089067629033265213778038935860228840044580431884740786045625803780635269807390186318135130999141


# m^e = c + k*n, probably k will be low.
k = 0
topK = 10
for i in range(topK):
    m, isExact = gmpy2.iroot(c + i*n, e) # https://gmpy2.readthedocs.io/en/latest/mpz.html#gmpy2.iroot
    if isExact:
        k = i
        break
print("k: ", k)
print("m: ", m)

plainText = long_to_bytes(m).decode()
print(plainText)